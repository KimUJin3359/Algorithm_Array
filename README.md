# Array

### 알고리즘의 성능
- **정확성** : 얼마나 정확하게 동작하는가
- **작업량** : 얼마나 적은 연산으로 원하는 결과를 얻어내는가(시간복잡성)
- **메모리 사용량** : 얼마나 적은 메모리를 사용하는가(공간복잡성)
- 단순성 : 얼마나 단순한가(코드의 이해가능 정도)
- **최적성** : 최적화 되었는가?

> ### 배열이란?
- **일정한 자료형**의 변수들을 **하나의 이름**으로 열거하여 사용하는 자료구조
- 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기힘든 작업을 배열을 활용해 쉽게할 수 있음

### 완전 탐색(Exhaustive Search)
- 문제의 해법으로 생각할 수 있는 **모든 경우의 수**를 나열해보고 확인하는 기법
- **Brute-force** 혹은 **generate-and-test 기법**으로도 불림

#### 순열(Permutation)
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

### 정렬
- 버블 정렬 (Bubble Sort)
  - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  - O(n^2)
- 카운팅 정렬 (Counting Sort)
  - 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 알고리즘
  - O(n + k) : n은 리스트 길이, k는 정수의 최대값

#### 관련 문제
[1. Flatten](https://github.com/KimUJin3359/Array/tree/master/Flatten)
- 높은 곳의 상자를 낮은 곳에 옮기는 작업
- 상자를 옮기는 작업 횟수에 제한이 걸려 있음
- 제한된 횟수만큼 옮기는 작업을 한 후 최고점과 최저점의 차이를 반환하는 프로그램

#### 생각해야 되는 부분
- 평탄화 작업이 다 됐을 경우의 판단
[코드](https://github.com/KimUJin3359/Array/blob/master/Flatten/Flatten/main.cpp)

[2. Frequency](https://github.com/KimUJin3359/Array/tree/master/Frequency)
- 평범한 최빈수를 구하는 문제

[3. View](https://github.com/KimUJin3359/Array/tree/master/View)
- 양 쪽 2칸 이상의 공간이 확보될 때 조망권이 확보된다고 할 때, 조망권이 확보된 세대의 수를 구하는 프로그램

#### 접근 방법
- 현 빌딩의 높이 - 양쪽 두칸에서의 최대값 > 0인 경우 조망권이 확보된다고 할 수 
